ft_color_init.c:	r = ft_atoi(data->texture.c_color[0]);
ft_color_init.c:	g = ft_atoi(data->texture.c_color[1]);
ft_color_init.c:	b = ft_atoi(data->texture.c_color[2]);
ft_color_init.c:		data->c_color = r;
ft_color_init.c:		data->c_color = (data->c_color << 8) + g;
ft_color_init.c:		data->c_color = (data->c_color << 8) + b;
ft_color_init.c:	r = ft_atoi(data->texture.f_color[0]);
ft_color_init.c:	g = ft_atoi(data->texture.f_color[1]);
ft_color_init.c:	b = ft_atoi(data->texture.f_color[2]);
ft_color_init.c:		data->f_color = r;
ft_color_init.c:		data->f_color = (data->f_color << 8) + g;
ft_color_init.c:		data->f_color = (data->f_color << 8) + b;
ft_dda.c:	if (data->raycast.side_dist_x < data->raycast.side_dist_y)
ft_dda.c:		data->raycast.side_dist_x += data->raycast.delta_dist_x;
ft_dda.c:		data->raycast.map_x += data->raycast.step_x;
ft_dda.c:		if (data->raycast.step_x == -1)
ft_dda.c:			data->raycast.side = 0;
ft_dda.c:			data->raycast.side = 1;
ft_dda.c:		data->raycast.side_dist_y += data->raycast.delta_dist_y;
ft_dda.c:		data->raycast.map_y += data->raycast.step_y;
ft_dda.c:		if (data->raycast.step_y == -1)
ft_dda.c:			data->raycast.side = 2;
ft_dda.c:			data->raycast.side = 3;
ft_dda.c:	while (data->raycast.hit != 1)
ft_dda.c:		if (data->map.map_int[data->raycast.map_y][data->raycast.map_x] >= 1 &&
ft_dda.c:				data->map.map_int[data->raycast.map_y][data->raycast.map_x] != 2)
ft_dda.c:				data->raycast.hit = 1;
ft_dda.c:		//else if (data->map.map[data->raycast.map_y][data->raycast.map_y] == 2)
ft_draw.c:	d = data->raycast.y * texture->size_line - HIEGHT * texture->size_line / 2
ft_draw.c:		+ data->raycast.line_height * texture->size_line / 2;
ft_draw.c:	data->raycast.text_y = ((d * texture->height) / data->raycast.line_height)
ft_draw.c:	data->image->img_data[data->raycast.y * data->image->size_line 
ft_draw.c:		+ data->raycast.x * data->image->bpp / 8] = 
ft_draw.c:		texture->img_data[data->raycast.text_y * texture->size_line
ft_draw.c:		+ data->raycast.text_x * (texture->bpp / 8)];
ft_draw.c:	data->image->img_data[data->raycast.y * data->image->size_line
ft_draw.c:			+ data->raycast.x * data->image->bpp / 8 + 1] = 
ft_draw.c:		texture->img_data[data->raycast.text_y * texture->size_line 
ft_draw.c:			+ data->raycast.text_x * (texture->bpp / 8) + 1];
ft_draw.c:	data->image->img_data[data->raycast.y * data->image->size_line
ft_draw.c:			+ data->raycast.x * data->image->bpp / 8 + 2] = 
ft_draw.c:		texture->img_data[data->raycast.text_y * texture->size_line 
ft_draw.c:			+ data->raycast.text_x * (texture->bpp / 8) + 2];
ft_draw.c:	data->raycast.y++;
ft_draw.c:	data->raycast.y = data->raycast.draw_start;
ft_draw.c:	while (data->raycast.y <= data->raycast.draw_end)
ft_draw.c:	texture = data->west;
ft_draw.c:	if (data->raycast.side == 1)
ft_draw.c:		texture = data->east;
ft_draw.c:	else if (data->raycast.side == 2)
ft_draw.c:		texture = data->north;
ft_draw.c:	else if (data->raycast.side == 3)
ft_draw.c:		texture = data->south;
ft_draw.c:	text_x = (int)(data->raycast.wall_x * (double)texture->width);
ft_draw.c:	if ((data->raycast.side == 0 || data->raycast.side == 1) && data->raycast.ray_dir_x > 0)
ft_draw.c:	if ((data->raycast.side == 2 || data->raycast.side == 3) && data->raycast.ray_dir_y < 0)
ft_draw.c:	data->raycast.text_x = text_x;
ft_draw.c:	while (y < data->raycast.draw_start)
ft_draw.c:		mlx_put(data->image, data->raycast.x, y++, data->c_color);
ft_draw.c:	y = data->raycast.draw_end + 1;
ft_draw.c:		mlx_put(data->image, data->raycast.x, y++, data->f_color);
ft_draw.c:	data->raycast.draw_start = -data->raycast.line_height / 2 + WIDTH / 2;
ft_draw.c:	data->raycast.draw_end = data->raycast.line_height / 2 + HIEGHT / 2;
ft_draw.c:	if (data->raycast.draw_start < 0)
ft_draw.c:		data->raycast.draw_start = 0;
ft_draw.c:	if (data->raycast.draw_end >= HIEGHT)
ft_draw.c:		data->raycast.draw_end = HIEGHT - 1;
ft_draw.c:	if (data->raycast.side == 0 || data->raycast.side == 1)
ft_draw.c:		data->raycast.wall_x = data->player->pos_y 
ft_draw.c:			+ data->raycast.prep_wall_dist * data->raycast.ray_dir_y;
ft_draw.c:		data->raycast.wall_x = data->player->pos_x
ft_draw.c:				+ data->raycast.prep_wall_dist * data->raycast.ray_dir_x;
ft_draw.c:	data->raycast.wall_x -= floor(data->raycast.wall_x);
ft_raycasting.c:	if (data->raycast.ray_dir_y == 0)
ft_raycasting.c:		data->raycast.delta_dist_x = 0;
ft_raycasting.c:	else if (data->raycast.ray_dir_x == 0)
ft_raycasting.c:		data->raycast.delta_dist_x = 1;
ft_raycasting.c:		data->raycast.delta_dist_x = fabs(1 / data->raycast.ray_dir_x);
ft_raycasting.c:	if (data->raycast.ray_dir_x == 0)
ft_raycasting.c:		data->raycast.delta_dist_y = 0;
ft_raycasting.c:	else if (data->raycast.ray_dir_y == 0)
ft_raycasting.c:		data->raycast.delta_dist_y = 1;
ft_raycasting.c:		data->raycast.delta_dist_y = fabs(1 / data->raycast.ray_dir_y);
ft_raycasting.c:	if (data->raycast.ray_dir_x < 0)
ft_raycasting.c:		data->raycast.step_x = -1;
ft_raycasting.c:		data->raycast.side_dist_x = (data->player->pos_x - data->raycast.map_x)
ft_raycasting.c:				* data->raycast.delta_dist_x;
ft_raycasting.c:		data->raycast.step_x = 1;
ft_raycasting.c:		data->raycast.side_dist_x = (data->raycast.map_x - data->player->pos_x + 1.0)
ft_raycasting.c:				* data->raycast.delta_dist_x;
ft_raycasting.c:	if (data->raycast.ray_dir_y < 0)
ft_raycasting.c:		data->raycast.step_y = -1;
ft_raycasting.c:		data->raycast.side_dist_y = (data->player->pos_y - data->raycast.map_y)
ft_raycasting.c:				* data->raycast.delta_dist_y;
ft_raycasting.c:		data->raycast.step_y = 1;
ft_raycasting.c:		data->raycast.side_dist_y = (data->raycast.map_y - data->player->pos_y + 1.0)
ft_raycasting.c:				* data->raycast.delta_dist_y;
ft_raycasting.c:	data->raycast.camera_x = 2 * data->raycast.x / (double)WIDTH - 1;
ft_raycasting.c:	data->raycast.ray_dir_x = data->player->dir_x
ft_raycasting.c:		+ data->player->plan_x * data->raycast.camera_x;
ft_raycasting.c:	data->raycast.ray_dir_y =data->player->dir_y
ft_raycasting.c:		+ data->player->plan_y * data->raycast.camera_x;
ft_raycasting.c:	data->raycast.hit = 0;
ft_raycasting.c:	data->raycast.map_x = (int)data->player->pos_x;
ft_raycasting.c:	data->raycast.map_y = (int)data->player->pos_y;
ft_raycasting.c:	data->raycast.line_height = 0;
ft_raycasting.c:	data->raycast.y = 0;
ft_raycasting.c:	if (data->raycast.side == 0 || data->raycast.side == 1)
ft_raycasting.c:		data->raycast.prep_wall_dist = (data->raycast.map_x - data->player->pos_x +
ft_raycasting.c:			(1 - data->raycast.step_x) / 2) / data->raycast.ray_dir_x;
ft_raycasting.c:	else if (data->raycast.side == 2 || data->raycast.side == 3)
ft_raycasting.c:		data->raycast.prep_wall_dist = (data->raycast.map_y - data->player->pos_y +
ft_raycasting.c:				(1 - data->raycast.step_y) / 2) / data->raycast.ray_dir_y;
ft_raycasting.c:	data->raycast.line_height = (int)(WIDTH / data->raycast.prep_wall_dist);
ft_raycasting.c:	data->raycast.z_buffer[data->raycast.x] = data->raycast.prep_wall_dist;	
ft_raycasting.c:	data->raycast.x = 0;
ft_raycasting.c:	data->raycast.z_buffer = (double *)malloc(sizeof(double) * WIDTH);
ft_raycasting.c:	if (!data->raycast.z_buffer)
ft_raycasting.c:	ft_bzero(data->raycast.z_buffer, sizeof(double) * WIDTH);
ft_raycasting.c:	while (data->raycast.x < WIDTH)
ft_raycasting.c:		data->raycast.x++;
ft_raycasting.c://	if (data->sprites_head != NULL)
ft_raycasting.c://	free(data->raycast.z_buffer);
ft_raycasting.c://	if (data->save == 1)
ft_raycasting.c:	mlx_put_image_to_window(data->mlx.mlx_ptr, data->mlx.win_ptr, data->image->img_ptr, 0,0);
ft_sprites.c:	new->x = data->raycast.map_x;
ft_sprites.c:	new->y = data->raycast.map_y;
ft_sprites.c:	current = data->sprites_head;
ft_sprites.c:	distance = (data->player->pos_x - new->x) * (data->player->pos_y - new->x)
ft_sprites.c:			+ (data->player->pos_x - new->x) * (data->player->pos_y - new->y);
ft_sprites.c:	sorted_insert(&(data->sprites_head), new_sprite);
ft_textur_init.c:	if (!(image->img_ptr = mlx_xpm_file_to_image(data->mlx.mlx_ptr,
ft_textur_init.c:	set_texture(data, data->north);
ft_textur_init.c:	set_texture(data, data->south);
ft_textur_init.c:	set_texture(data, data->west);
ft_textur_init.c:	set_texture(data, data->east);
ft_textur_init.c:	if(!(data->north = image_init()))
ft_textur_init.c:		data->north->path = data->texture.north;
ft_textur_init.c:	if(!(data->south = image_init()))
ft_textur_init.c:		data->south->path = data->texture.south;
ft_textur_init.c:	if(!(data->west = image_init()))
ft_textur_init.c:		data->west->path = data->texture.west;
ft_textur_init.c:	if(!(data->east = image_init()))
ft_textur_init.c:		data->east->path = data->texture.east;
ft_textur_init.c:	if (!(data->image = image_init()))
get_map.c:	if(i == 0 || i == data->map.y_map)
get_map.c:		free(data->map.map);
get_map.c:		close(data->fd);
get_map.c:		data->map.map[i] = malloc(sizeof(char) * len);
get_map.c:			data->map.map[i][x] = line[index];
get_map.c:		data->map.map[i][x++] = '\0';
get_map.c:	data->map.map_int = malloc(sizeof(int *) * data->map.y_map + 1);
get_map.c:	if (!data->map.map_int)
get_map.c:	while (data->map.map[++i])
get_map.c:		len = calcul_nbr(data->map.map[i]);
get_map.c:		data->map.map_int[i] = malloc(sizeof(int) * len);
get_map.c:		if (!data->map.map_int[i])
get_map.c:		temp = ft_strtrim(data->map.map[i], " ");
get_map.c:			data->map.map_int[i][j] = (temp[j] + 48);
get_map.c:	data->map.map_int[i] = NULL; 
get_map.c:	data->map.y_map = count_y(argv);
get_map.c:	data->map.map = malloc(sizeof(char *) * data->map.y_map + 1);
get_map.c:		while (data->map.index-- > 0)
get_map.c:			line = get_next_line(data->fd2);
get_map.c:		line = get_next_line(data->fd2);
get_map.c:	data->map.map[data->map.y_map + 1] = NULL;
get_map_utils.c:	while (data->map.map[++i])
get_map_utils.c:		free(data->map.map[i]);
get_map_utils.c:	free(data->map.map);
get_map_utils.c:	close(data->fd);
get_map_utils.c:		data->texture.north = tmp[1];
get_map_utils.c:		data->texture.south = tmp[1];
get_map_utils.c:		data->texture.west = tmp[1];
get_map_utils.c:		data->texture.east = tmp[1];
get_map_utils.c:	data->texture.index++;
get_map_utils.c:			data->texture.index++;
get_map_utils.c:			data->texture.f_color = ft_split(temp, ',');
get_map_utils.c:			data->texture.index++;
get_map_utils.c:			data->texture.c_color = ft_split(temp, ',');
get_map_utils.c:	data->index = 0;
get_map_utils.c:		data->map.line = get_next_line(data->fd);
get_map_utils.c:		if (!data->map.line)
get_map_utils.c:		if (line_check(data->map.line) == 0)
get_map_utils.c:		tmp = ft_split(data->map.line, ' ');
get_map_utils.c:		if (!tmp[1] && data->map.line[0] !=  '\n')
get_map_utils.c:		if (get_colors(data, data->map.line) == 1)
get_map_utils.c:		free(data->map.line);
get_map_utils.c:		data->index++;
get_pos_player.c:	if (data->player->dir == '0')
get_pos_player.c:	else if (data->player->dir == 'N' || data->player->dir == 'S')
get_pos_player.c:		data->player->dir_x = 0;
get_pos_player.c:		if (data->player->dir == 'N')
get_pos_player.c:			data->player->dir_y = -1;
get_pos_player.c:			data->player->dir_y = 1;
get_pos_player.c:		if (data->player->dir == 'N')
get_pos_player.c:			data->player->plan_x = 0.66;
get_pos_player.c:			data->player->plan_x = -0.66;
get_pos_player.c:		data->player->plan_y = 0;
get_pos_player.c:	else if (data->player->dir == 'W' || data->player->dir == 'E')
get_pos_player.c:		data->player->dir_y = 0;
get_pos_player.c:		if (data->player->dir == 'W')
get_pos_player.c:			data->player->dir_x = -1;
get_pos_player.c:			data->player->dir_x = 1;
get_pos_player.c:		if (data->player->dir == 'W')
get_pos_player.c:			data->player->plan_y = 0.66;
get_pos_player.c:			data->player->plan_y = -0.66;
get_pos_player.c:		data->player->plan_x = 0;
get_pos_player.c:	while (data->map.map[i])
get_pos_player.c:		while (data->map.map[i][j])
get_pos_player.c:			if (data->map.map[i][j] == 'N' 
get_pos_player.c:				|| data->map.map[i][j] == 'E' 
get_pos_player.c:				|| data->map.map[i][j] == 'W' 
get_pos_player.c:				|| data->map.map[i][j] == 'S')
get_pos_player.c:				data->player->dir = data->map.map[i][j];
main.c:	data->fd = open(argv[1], O_RDONLY);
main.c:	data->fd2 = open(argv[1], O_RDONLY);
main.c:	if (data->fd < 0 || data->fd2 < 0)
main.c:	data->player = init_player(data);
main.c:	ft_display(data->map.map);
start_mlx.c:	mlx_destroy_window(data->mlx.mlx_ptr, data->mlx.win_ptr);
start_mlx.c:	mlx_destroy_display(data->mlx.mlx_ptr);
start_mlx.c:	free(data->mlx.mlx_ptr);
start_mlx.c:	if (data->save == 1)
start_mlx.c:	mlx_hook(data->mlx.win_ptr, 17, 0L, &ft_close, data);
start_mlx.c:	mlx_key_hook(data->mlx.win_ptr, &handel_input, data);
start_mlx.c:	mlx_loop_hook(data->mlx.mlx_ptr, &handel_no_even, data);
start_mlx.c:	mlx_loop(data->mlx.mlx_ptr);
start_mlx_utils.c:	data->mlx.mlx_ptr = mlx_init();
start_mlx_utils.c:	if (!(data->mlx.mlx_ptr))
start_mlx_utils.c:	data->mlx.win_ptr = mlx_new_window(data->mlx.mlx_ptr, WIDTH, HIEGHT, "CUB3D");
start_mlx_utils.c:	if (!(data->mlx.win_ptr))
start_mlx_utils.c:	data->image->img_ptr = mlx_new_image(data->mlx.mlx_ptr , WIDTH, HIEGHT);
start_mlx_utils.c:	data->image->img_data = mlx_get_data_addr(data->image->img_ptr, &(data->image->bpp), &(data->image->size_line),
start_mlx_utils.c:					&(data->image->endian));
